%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definición del tipo de documento.                                           %
% Posibles tipos de papel: a4paper, letterpaper, legalpapper                  %
% Posibles tamaños de letra: 10pt, 11pt, 12pt                                 %
% Posibles clases de documentos: article, report, book, slides                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[a4paper,10pt]{article}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Los paquetes permiten ampliar las capacidades de LaTeX.                     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Paquete para inclusión de gráficos.
\usepackage{graphicx}

% Paquete para definir la codificación del conjunto de caracteres usado
% (latin1 es ISO 8859-1).
\usepackage[latin1]{inputenc}

% Paquete para definir el idioma usado.
\usepackage[spanish]{babel}

\usepackage{multirow} 

% Paquete para fórmulas matemáticas
\usepackage{amsmath}
\newcommand{\BigO}[1]{\ensuremath{\operatorname{O}\bigl(#1\bigr)}}

%\usepackage{multicolumn} 

% Título principal del documento.
\title{		\textbf{Trabajo práctico 0: Infraestructura básica}}

% Información sobre los autores.
\author{	Alejandro García Marra, \textit{Padrón Nro. 91.516}                     \\
            \texttt{ alemarra@gmail.com }                                              \\
            Sebastián Javier Bogado, \textit{Padrón Nro. 91.707}                     \\
            \texttt{ sebastian.j.bogado@gmail.com }                                              \\
            \normalsize{Grupo Nro. 0 - 2do. Cuatrimestre de 2012}                       \\
            \normalsize{66.20 Organización de Computadoras}                             \\
            \normalsize{Facultad de Ingeniería, Universidad de Buenos Aires}            \\
       }
\date{}



\begin{document}

% Inserta el título.
\maketitle

% Quita el número en la primer página.
\thispagestyle{empty}

% Resumen
\begin{abstract}

El presente trabajo busca crear un programa que permita el ordenamiento de archivos a través de dos implementaciones distintas, una utilizando el algoritmo Quicksort y la otra el algoritmo Stooge sort.\\
Sobre este programa, luego, se realizarán una serie de mediciones con el fin de determinar los desempeños relativos de cada implementación y las posibles mejoras a realizar. 
Para esto haremos uso de los programas \textbf{time} y \textbf{gprof}.

\end{abstract}

\newpage
\section{Introducción}

Muchas veces tanto para programas recién terminados, como para aquellos que llevan un tiempo en funcionamiento, se desconoce realmente qué partes del programa insumen la mayor cantidad de recursos, sean estos de tiempo, carga de cpu, etc.
Poseer esta información se torna en algo crítico cuando se busca realizar una mejora de performance en dicho programa. Sería poco útil intentar optimizar a ciegas, por no decir inútil.\\
Haremos uso entonces de dos herramientas distintas, el profiling del código (por medio de \textit{gprof}) y la medición de los tiempos de ejecución (por medio de \textit{time}). 

\begin{itemize}
 \item \textbf{Profiling}: El profiling permite aprender donde el programa pasa la mayor parte de su tiempo, y cuales funciones llaman a otras mientras se ejecuta.\\
 			   Esta informacion puede mostrar qué piezas del programa son mas lentas de lo esperado, convirtiéndolas en candidatas para su reescritura en la etapa de optimización.\\
 			   También puede ayudarnos a descubrir cuales funciones son llamadas más o menos veces delo esperado, pudiendo así encontrar nuevos bugs (aunque el descubrimiento de bugs no es el fin principal de esta etapa)
 			   
			   El profiler utiliza información recolectada en tiempo de ejecución, por lo que puede ser utilizado en programas demasiado grandes o complejos, donde un análisis por lectura de fuentes sería impracticable.\\
			   Como consecuencia del análisis durante la ejecución, los datos con los que se corra el programa afectaran el resultado del profiler. 
			   Es decir, distintos datos de entrada pueden provocar distintas ramas de ejecución, dando po resultado que, por ejemplo, no se llamen algunas funciones.
			   
\item \textbf{Medición de Tiempos}: Permite conocer con precisión los tiempos de ejecución de un programa, discriminados entre tiempos de systema, de usario, tiempos totales, etc., así como también conocer los porcentajes para cada parte del programa, cantidad de entradas, y muchas otras opciones.\\
				     La combinación con una herramienta de profiling permite exactitud a la hora de conocer la forma en que se ejecuta el programa bajo estudio, permitiendo optimizar únicamente las partes críticas del ciclo de ejecución.
\end{itemize}


\newpage

\section{Métodos de ordenamiento}
\subsection{Quicksort}
*******AGREGAR todas las tildes, NO LO HICE para no romper la compilacion entre linux y windows****

El Quicksort es un algoritmo recursivo del tipo divide y venceras, que consiste en dos etapas, una de particion del problema y otra de reordenamiento.

Las etapas se intercalan de la siguiente forma: se elige arbitrariamente un elemento denominado \textbf{pivot}, y se reordena la particion de forma tal que los elementos mayores esten en la mitad superior al pivot, y los menores en la mitad inferior de la particion.
Luego, se quita al pivot del problema y se opera recursivamente sobre las dos sub particiones generadas (aquella con los elemenos mayores y otra con los elementos menores al pivot).
Una vez terminado el ordenamiento, a medida que retorna la funcion, se genera la particion ordenada.

Se eligio implementar la version \textit{in-place} del algoritmo de particion, puesta permite obtener resultados en tiempos \BigO{\log{n}} en promedio.

\subsection{Stooge sort}
El Stooge sort es un algoritmo de ordenamiento recursivo muy ineficiente, de complejidad \BigO{n^{\log{3}/\log{1,5}}}.\\
Realiza el intercambio entre el primer y último de los elementos si es el primero es mayor (en ordenamiento ascendente). Luego, si el conjunto está compuesto por al menos tres valores, entonces aplica Stooge sort a los primeros dos tercios, luego a los dos últimos tercios, y finalmente repite con los primeros dos tercios. 


\section{Flujo del programa}

El programa comienza verificando el primer parámetro recibido. Si no existe o no es reconocido, sucede el comportamiento por defecto, que es el mensaje de ayuda, información sobre el uso. Con esto, termina la ejecución. Otro camino rápido en la aplicación es al solicitar la versión, con el parámetro \texttt{-V} o \texttt{--version}.\\

Si el primer parámetro solicitó un algoritmo de ordenamiento (\texttt{-q} o \texttt{--quick} para Quicksort y \texttt{-s} o \texttt{--stooge} para el Stooge sort), entra en el corazón del programa: la función
\texttt{void sort(unsigned n, char* files[], \\line** (*sort\_func)(line** , unsigned ))}:

\begin{itemize}
 \item \texttt{n}: la cantidad de archivos sobre los que se aplicará el ordenamiento. Si es cero, se tomará la entrada estándar.
 \item \texttt{files}: los nombres de los archivos
 \item \texttt{sort\_func}: puntero a la función de ordenamiento seleccionada anteriormente con el primer parámetro
\end{itemize}

En el archivo \texttt{line.h} se encuentra definido el tipo homónimo, desde \texttt{typedef struct line line}. Esto fue necesario porque en un archivo podría aparecer un byte nulo antes de el byte 10, aquél tomado como fin de línea. Como las cadenas en C terminan en un byte nulo, todas las funciones estándar de la librería \texttt{<string.h>} resultaron inservibles porque necesitábamos que fuera otro el indicador de fin.\\

Volviendo a la función \texttt{sort}, se arma el conjunto de líneas a ser reordeanadas recolectándolas de a un archivo por vez. Si no hubiera archivos, se trabaja con la entrada estándar con la misma función (\texttt{parseLineas}, que se detallará en breve).\\

Armado el conjunto, se llama a la función de ordenamiento desde su puntero pasándole como parámetros el vector de líneas y la cantidad de elementos. Luego se imprimen por salda estándar y se libera la memoria reservada, todo esto con funciones propias para el tipo \texttt{line}.\\

La lectura de cada archivo sucede en la función
\texttt{unsigned parseLineas(\\line** *pLinea, unsigned lineas, FILE* stream)}:

\begin{itemize}
 \item \texttt{pLinea}: puntero a un arreglo de punteros a \texttt{line}
 \item \texttt{lineas}: cantidad de elementos del arreglo
 \item \texttt{stream}: archivo desde donde se llevarán a cabo las lecturas
 \item \texttt{return}: cantidad de elementos en el arreglo después del proceso
\end{itemize}

Esta función carga en un buffer el archivo y lo recorre en busca del caracter de fin de línea. Por cada uno encontrado, se aloca espacio para un \texttt{line}, mediante sus métodos dedicados, y se agrega al vector. Si el archivo no termina naturalmente como una línea, se agrega al final el \texttt{EOL}. Retorna con la cantidad de líneas cargadas (las acumuladas y las nuevas del archivo actual).



\section{Mediciones}

\subsection{Valores Obtenidos}

En la tabla~\ref{tab001} se presentan las mediciones realizadas con \textbf{time} sobre ambos algoritmos de ordenamiento y con archivos de distintos tamaños.\\

Además de los archivos indicados en el enunciado, fueron agregadas mediciones sobre archivos con tamaños arbitrarios, mayores, con el fin de mostrar de mejor manera las diferencias entre algoritmos.

\begin{table}[!htp]
\begin{center}
\begin{tabular}{cc|c|c|c|c|c|c|} 
\cline{3-8}
& & \multicolumn{3}{ c|}{Quicksort} & \multicolumn{3}{c|}{Stooge sort}\\ \cline{3-8}
&   & Ordenado & Invertido & Aleatorio & Ordenado & Invertido & Aleatorio \\ \cline{1-8}
\multicolumn{1}{|c}{\multirow{3}{*}{1kb}} &
\multicolumn{1}{|c|}{real$^{*}$} &	 0.02 &	0.00 &	0.00 &	0.00 &	0.00 &	0.00 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{user$^{*}$} &	0.00 &	0.00 &	0.00 &	0.00 &	0.00 &	0.00 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{sys$^{*}$} & 0.00 & 0.00 &0.00 & 0.00 & 0.00 & 0.00 \\ \cline{1-8}
\multicolumn{1}{|c}{\multirow{3}{*}{8kb}} &
\multicolumn{1}{|c|}{real} & 0.01 & 0.00 &0.00 & 0.02 & 0.02 & 0.02 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{user} & 0.00 & 0.00 &0.00 & 0.02 & 0.02 & 0.02 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{sys} & 0.00 & 0.00 &0.00 & 0.00 & 0.00 & 0.00 \\ \cline{1-8}
\multicolumn{1}{|c}{\multirow{3}{*}{16kb}} &
\multicolumn{1}{|c|}{real} & 0.00 & 0.00 &0.00 & 0.02 & 0.02 & 0.01 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{user} & 0.00 & 0.00 &0.00 & 0.02 & 0.02 & 0.01 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{sys} & 0.00 & 0.00 &0.00 & 0.00 & 0.00 & 0.00 \\ \cline{1-8}
\multicolumn{1}{|c}{\multirow{3}{*}{32kb}} &
\multicolumn{1}{|c|}{real} & 0.01 & 0.01 &0.00 & 0.37 & 0.38 & 0.37 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{user} & 0.00 & 0.00 &0.00 & 0.37 & 0.38 & 0.36 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{sys} & 0.00 & 0.00 &0.00 & 0.00 & 0.00 & 0.00 \\ \cline{1-8}
\multicolumn{1}{|c}{\multirow{3}{*}{64kb}} &
\multicolumn{1}{|c|}{real} & 0.00 & 0.00 &0.00 & 3.77 & 3.77 & 3.78 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{user} & 0.00 & 0.00 &0.00 & 3.76 & 3.76 & 3.78 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{sys} & 0.00 & 0.00 &0.00 & 0.00 & 0.00 & 0.00 \\ \cline{1-8}
\multicolumn{1}{|c}{\multirow{3}{*}{1024kb}} &
\multicolumn{1}{|c|}{real} & 0.17 & 0.17 &0.18 & $>$1500 & $>$1500 & $>$1500 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{user} & 0.15 & 0.14 &0.14 & $>$1500 & $>$1500 & $>$1500 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{sys} & 0.00 & 0.01 &0.01 & 0.00 & 0.00 & 0.00 \\ \cline{1-8}
\end{tabular}
\caption{Resultados comando Time } \label{tab001}
\end{center}
\end{table}

$^{*}$ Referencia: 
\begin{itemize}
 \item real: \%e, tiempo total real usado por el proceso.
 \item user: \%U, total de segundos-CPU usados por el proceso directamente.
 \item sys : \%S, total de segundos-CPU utilizados por el systema en nombre del proceso.
\end{itemize}



\subsection{Análisis de los datos}

La marcada diferencia entre la complejidad de los algoritmos se refleja en muestras tan chicas como la de 8kb. 
A partir de ahí, el Stooge sort ya hace suficiente uso del procesador como para ser notado por time, mientras que el Quicksort hace lo propio recién en la muestra más grande, de 1024kb. En este caso, el Stooge sort se tornó intolerable.

En la figura~\ref{fig001} se muestra el gráfico del tiempo insumido por el Quicksort para las distintas muestras.\\
En la figura~\ref{fig002} se muestra el gráfico del tiempo insumido por el Stooge sort para las distintas muestras, a excepción de la de 1024kb, porque demanda una escala que haría inapreciable la situación de las otras muestras.

%
%	\begin{figure}[!htp]
%	\begin{center}
%	\includegraphics[width=1\textwidth]{}
%	\end{center}
%	\caption{Tiempo tomado para distintas muestras del Quicksort.} \label{fig001}
%	\end{figure}

%	\begin{figure}[!htp]
%	\begin{center}
%	\includegraphics[width=1.1\textwidth]{}
%	\end{center}
%	\caption{Tiempo tomado para distintas muestras del Stooge sort.} \label{fig002}
%	\end{figure}
%

Al momento de calcular el speedup de Quicksort contra Stooge sort, con la razón entre los tiempos de cada uno, las cifras obtenidas no lo permiten. El primero no arroja resultados apreciables por \textbf{time} en ninguna instancia sin contar la última, donde el Stooge sort es inmanejable.\\

Esto es porque la complejidad del Quicksort es, en promedio, \BigO{n \log(n)}, mientras que el Stooge sort es de \BigO{n^{2,7}}. Entonces, el speedup entre ambos algoritmos tiende a infinito exponencialmente, según crece el tamaño de la muestra.


\section{Profiling}

Como se pudo apreciar en la tabla de tiempos de la página anterior, el algoritmo de quicksort resulta extremadamente veloz para tamaños de archivos relativamente grandes. Decidimos, entonces, forzar un poco más al programa y hacer el profiling sobre un archivo desordenado de 32mb. Además, para que las funciones mismas de \textbf{gprof} tuvieran una incidencia despreciable en la prueba.\\
Realizar esta misma prueba sobre el algoritmo Stooge sort, serí­a impracticable, ya que los tiempos demandados serían demasiado grandes.

Un punto interesante a destacar son llamadas a métodos de ordenamiento: como era de esperarse, no se realizan llamadas al método stoogesort, lo cual confirma que el algoritmo no es utilizado.
										
										   Por otra parte, para el método quicksort\_r que implementa dicho algoritmo, tenemos cientos de miles de llamados. Esto era de esperarse debido a las dimensiones del archivo y la naturaleza recursiva del algoritmo utilizado.

La tabla~\ref{tab002} es la salida del \textbf{gprof}, en particular aquella conocida como "flat profile". Muestra el uso de las funciones invocadas, ordenadas de mayor a menor según el porcentaje de tiempo de ejecución de cada una.

\begin{table}[!htp]
\begin{center}
\begin{tabular}{|r|r|r|r|r|r|r|}
\hline
	\%		&	cumulative  &	self	&			&	self	&	total	& \\
\hline          
	time	&	seconds		&	seconds	&	calls	&	s/call	&	s/call	&	name \\    
\hline
  98.46 	&  126.49  		& 126.49 	& 359372904 &   0.00    & 	0.00  	& linecmp 		\\
\hline
  1.35  	&  128.23  		&   1.73  	& 448399    & 	0.00    & 	0.00  	& particionar	\\
\hline
  0.16 		&  128.44  		&   0.21  	&      1    & 	0.21    & 	0.27  	& parseLineas 	\\
\hline
  0.11  	&  128.58  		&   0.14   	& 448800    & 	0.00    & 	0.00  	& printLine 	\\
\hline
  0.06  	&  128.66  		&   0.08   	& 448800    & 	0.00    & 	0.00  	& freeLine 		\\
\hline
  0.04  	&  128.71  		&   0.06   	& 448800    & 	0.00    & 	0.00  	& createLine	\\
\hline
  0.04  	&  128.76  		&   0.05  	& 3428822   & 	0.00    & 	0.00  	& swapLine 		\\
\hline
  0.02  	&  128.78  		&   0.02    &    1     	& 	0.02   	& 	128.30  & quickSort\_r  \\
\hline
  0.02  	&  128.80  		&   0.02    &    1     	& 	0.02   	& 	128.80  & sort 			\\
\hline
  0.00  	&  128.80  		&   0.00    &    1     	& 	0.00    & 	0.00  	& cargarBuffer  \\
\hline
  0.00  	&  128.80  		&   0.00    &    1     	& 	0.00    & 	0.00  	& check\_param  \\
\hline
  0.00  	&  128.80  		&   0.00    &    1     	& 	0.00   	& 	128.30 	& quick\_sort   \\
\hline
\end{tabular}
\caption{Ejemplo de tabla.} \label{tab002}
\end{center}
\end{table}
 

Se aprecia en la tabla que la función de comparación de lineas implementada ocupa el 98.46\% del tiempo de ejecución de programa, convirtiéndola en la candidata para mejorar. Dicha función se convierte en una parte crítica del programa pues es invocada en cada decisión de intercambio de lineas. \par
\medskip
Para calcular el speedup máximo, usamos la fórmula:

\begin{center}
$ speedup total = 1/(1-f + f/SM)$\\
\vspace{0.5cm}
$ f = 0,9846 $; SM tiende a infinito por ser arbitrariamente mejorable\\

\vspace{0.5cm}

$ Speedup maximo = 1/0,08123 = 12,3$
\end{center}


\newpage

\section{Comandos de ejecución y corridas de prueba}

Comandos de Compilación:

\begin{itemize}
 \item make all: genera el programa, modo "release"
 \item make debug: genera el programa con flags para debugging
 \item make asm: genera los archivos Assemblies, sin generar el programa
 \item make gprof: genera el programa con flags para \textbf{gprof}
 \item make clean: remueve los archivos generados
\end{itemize}

Comandos de Ejecución:

\begin{itemize}
 \item tp0 [OPTIONS] [file...]
 \item $<$stdout$>$ $|$ tp0 [OPTIONS]
 \item -h, --help
 \item -V, --version
 \item -q, --quicksort
 \item -s, --stoogesort
\end{itemize}



\section{Conclusiones}

El presente trabajo, a modo de introducción, nos inicializó en las herramientas que usaremos en los trabajos siguientes. % sinonimia cero

Pudimos manejar la máquina virtual MIPS e interpretar un archivo de profiling, como si estuviésemos optimizando un programa real.

Respecto de las velocidades observadas, podemos confirmar lo esperado a partir del análsis teórico. El algoritmo quicksort fue varios ordenes de magnitud más veloz que el stoogesort, al punto de poder procesar archivos que con el segundo no serían viables.
% Citas bibliográficas.
\begin{thebibliography}{99}

\bibitem{HEN00} J. L. Hennessy and D. A. Patterson, ``Computer Architecture. A Quantitative
Approach,'' 3ra Edición, Morgan Kaufmann Publishers, 2000.

\end{thebibliography}

\end{document}
