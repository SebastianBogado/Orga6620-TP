%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definición del tipo de documento.                                           %
% Posibles tipos de papel: a4paper, letterpaper, legalpapper                  %
% Posibles tamaños de letra: 10pt, 11pt, 12pt                                 %
% Posibles clases de documentos: article, report, book, slides                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[a4paper,10pt]{article}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Los paquetes permiten ampliar las capacidades de LaTeX.                     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Paquete para inclusión de gráficos.
\usepackage{graphicx}

% Paquete para definir la codificación del conjunto de caracteres usado
% (latin1 es ISO 8859-1).
\usepackage[latin1]{inputenc}

% Paquete para definir el idioma usado.
\usepackage[spanish]{babel}

\usepackage{multirow} 

% Paquete para fórmulas matemáticas
%\usepackage{amsmath}
%\newcommand{\BigO}[1]{\ensuremath{\operatorname{O}\bigl(#1\bigr)}}

%\usepackage{multicolumn} 

% Título principal del documento.
\title{		\textbf{Trabajo práctico 0: Infraestructura básica}}

% Información sobre los autores.
\author{	Alejandro García Marra, \textit{Padrón Nro. 91.516}                     \\
            \texttt{ alemarra@gmail.com }                                              \\
            Sebastián Javier Bogado, \textit{Padrón Nro. 91.707}                     \\
            \texttt{ sebastian.j.bogado@gmail.com }                                              \\
            \normalsize{Grupo Nro. 0 - 2do. Cuatrimestre de 2012}                       \\
            \normalsize{66.20 Organización de Computadoras}                             \\
            \normalsize{Facultad de Ingeniería, Universidad de Buenos Aires}            \\
       }
\date{}



\begin{document}

% Inserta el título.
\maketitle

% Quita el número en la primer página.
\thispagestyle{empty}

% Resumen
\begin{abstract}

El presente trabajo busca crear un programa que permita el ordenamiento de archivos a través de dos implementaciones distintas, una utilizando el algoritmo Quicksort y la otra el algoritmo Stooge sort.\\
Sobre este programa, luego, se realizarán una serie de mediciones con el fin de determinar los desempeños relativos de cada implementación y las posibles mejoras a realizar. 
Para esto haremos uso de los programas \textbf{time} y \textbf{gprof}.

\end{abstract}

\newpage
\section{Introducción}

Muchas veces tanto para programas recién terminados, como para aquellos que llevan un tiempo en funcionamiento, se desconoce realmente qué partes del programa insumen la mayor cantidad de recursos, sean estos de tiempo, carga de cpu, etc.
Poseer esta información se torna en algo crítico cuando se busca realizar una mejora de performance en dicho programa. Sería poco útil intentar optimizar a ciegas, por no decir inútil.\\
Haremos uso entonces de dos herramientas distintas, el profiling del código (por medio de \textit{gprof}) y la medición de los tiempos de ejecución (por medio de \textit{time}). 

\begin{itemize}
 \item \textbf{Profiling}: El profiling permite aprender donde el programa pasa la mayor parte de su tiempo, y cuales funciones llaman a otras mientras se ejecuta.\\
 			   Esta informacion puede mostrar qué piezas del programa son mas lentas de lo esperado, convirtiéndolas en candidatas para su reescritura en la etapa de optimización.\\
 			   También puede ayudarnos a descubrir cuales funciones son llamadas más o menos veces delo esperado, pudiendo así encontrar nuevos bugs (aunque el descubrimiento de bugs no es el fin principal de esta etapa)
 			   
			   El profiler utiliza información recolectada en tiempo de ejecución, por lo que puede ser utilizado en programas demasiado grandes o complejos, donde un análisis por lectura de fuentes sería impracticable.\\
			   Como consecuencia del análisis durante la ejecución, los datos con los que se corra el programa afectaran el resultado del profiler. 
			   Es decir, distintos datos de entrada pueden provocar distintas ramas de ejecución, dando po resultado que, por ejemplo, no se llamen algunas funciones.
			   
\item \textbf{Medición de Tiempos}: Permite conocer con precisión los tiempos de ejecución de un programa, discriminados entre tiempos de systema, de usario, tiempos totales, etc., así como también conocer los porcentajes para cada parte del programa, cantidad de entradas, y muchas otras opciones.\\
				     La combinación con una herramienta de profiling permite exactitud a la hora de conocer la forma en que se ejecuta el programa bajo estudio, permitiendo optimizar únicamente las partes críticas del ciclo de ejecución.
\end{itemize}


\newpage

\section{Mediciones}

\subsection{Valores Obtenidos}

En la tabla~\ref{tab001} se presentan las mediciones realizadas con \textbf{time} sobre ambos algoritmos de ordenamiento y con archivos de distintos tamaños.\\

Además de los archivos indicados en el enunciado, fueron agregadas mediciones sobre archivos con tamaños arbitrarios, mayores, con el fin de mostrar de mejor manera las diferencias entre algoritmos.

\begin{table}[!htp]
\begin{center}
\begin{tabular}{cc|c|c|c|c|c|c|} 
\cline{3-8}
& & \multicolumn{3}{ c|}{Quicksort} & \multicolumn{3}{c|}{Stooge sort}\\ \cline{3-8}
&   & Ordenado & Invertido & Aleatorio & Ordenado & Invertido & Aleatorio \\ \cline{1-8}
\multicolumn{1}{|c}{\multirow{3}{*}{1kb}} &
\multicolumn{1}{|c|}{real$^{*}$} & 0.00 & 0.00 &0.00 & 0.00 & 0.00 & 0.00 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{user$^{*}$} & 0.00 & 0.00 &0.00 & 0.00 & 0.00 & 0.00 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{sys$^{*}$} & 0.00 & 0.00 &0.00 & 0.00 & 0.00 & 0.00 \\ \cline{1-8}
\multicolumn{1}{|c}{\multirow{3}{*}{8kb}} &
\multicolumn{1}{|c|}{real} & 0.00 & 0.00 &0.00 & 0.02 & 0.02 & 0.01 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{user} & 0.00 & 0.00 &0.00 & 0.01 & 0.01 & 0.01 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{sys} & 0.00 & 0.00 &0.00 & 0.00 & 0.00 & 0.00 \\ \cline{1-8}
\multicolumn{1}{|c}{\multirow{3}{*}{16kb}} &
\multicolumn{1}{|c|}{real} & 0.00 & 0.00 &0.00 & 0.00 & 0.02 & 0.02 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{user} & 0.00 & 0.00 &0.00 & 0.00 & 0.01 & 0.02 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{sys} & 0.00 & 0.00 &0.00 & 0.00 & 0.00 & 0.00 \\ \cline{1-8}
\multicolumn{1}{|c}{\multirow{3}{*}{32kb}} &
\multicolumn{1}{|c|}{real} & 0.00 & 0.00 &0.00 & 0.17 & 0.17 & 0.17 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{user} & 0.00 & 0.00 &0.00 & 0.17 & 0.17 & 0.17 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{sys} & 0.00 & 0.00 &0.00 & 0.00 & 0.00 & 0.00 \\ \cline{1-8}
\multicolumn{1}{|c}{\multirow{3}{*}{64kb}} &
\multicolumn{1}{|c|}{real} & 0.00 & 0.00 &0.00 & 1.44 & 1.44 & 1.44 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{user} & 0.00 & 0.00 &0.00 & 1.44 & 1.43 & 1.44 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{sys} & 0.00 & 0.00 &0.00 & 0.00 & 0.00 & 0.00 \\ \cline{1-8}
\multicolumn{1}{|c}{\multirow{3}{*}{1024kb}} &
\multicolumn{1}{|c|}{real} & 0.04 & 0.03 &0.03 & $>$1500 & $>$1500 & $>$1500 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{user} & 0.03 & 0.02 &0.03 & $>$1500 & $>$1500 & $>$1500 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{sys} & 0.00 & 0.00 &0.00 & 0.00 & 0.00 & 0.00 \\ \cline{1-8}
\end{tabular}
\caption{Resultados comando Time } \label{tab001}
\end{center}
\end{table}

$^{*}$ Referencia: 
\begin{itemize}
 \item real: \%e, tiempo total real usado por el proceso.
 \item user: \%U, total de segundos-CPU usados por el proceso directamente.
 \item sys : \%S, total de segundos-CPU utilizados por el systema en nombre del proceso.
\end{itemize}



\subsection{Análisis de los datos}

La marcada diferencia entre la complejidad de los algoritmos se refleja en muestras tan chicas como la de 8kb. 
A partir de ahí, el Stooge sort ya hace suficiente uso del procesador como para ser notado por time, mientras que el Quicksort hace lo propio recién en la muestra más grande, de 1024kb. En este caso, el Stooge sort se tornó intolerable.

En la figura~\ref{fig001} se muestra el gráfico del tiempo insumido por el Quicksort para las distintas muestras.\\
En la figura~\ref{fig002} se muestra el gráfico del tiempo insumido por el Stooge sort para las distintas muestras, a excepción de la de 1024kb, porque demanda una escala que haría inapreciable la situación de las otras muestras.

\begin{figure}[!htp]
\begin{center}
\includegraphics[width=1\textwidth]{quicksort.png}
\end{center}
\caption{Tiempo tomado para distintas muestras del Quicksort.} \label{fig001}
\end{figure}

\begin{figure}[!htp]
\begin{center}
\includegraphics[width=1.1\textwidth]{stoogesort.png}
\end{center}
\caption{Tiempo tomado para distintas muestras del Stooge sort.} \label{fig002}
\end{figure}


Al momento de calcular el speedup de Quicksort contra Stooge sort, con la razón entre los tiempos de cada uno, las cifras obtenidas no lo permiten. El primero no arroja resultados apreciables por \textbf{time} en ninguna instancia sin contar la última, donde el Stooge sort es inmanejable.\\
Finalmente, el speedup entre ambos tiene a infinito exponencialmente, según crece el tamaño de la muestra.
%Esto es porque la complejidad del Quicksort es, en promedio, \BigO{n \log(n)}, mientras que el Stooge sort es de \BigO{n^{2,7}}. Entonces, el speedup entre ambos algoritmos tiende a infinito exponencialmente, según crece el tamaño de la muestra.


\newpage

\section{Profiling}

Para realizar el profiling tomamos una muestra suficientemente grande como para que las funciones mismas de \textbf{gprof} tuvieran una incidencia despreciable en la prueba.\\
La tabla~\ref{tab002} es la salida del \textbf{gprof}, en particular aquella conocida como "flat profile". Muestra el uso de las funciones invocadas, ordenadas de mayor a menor según el porcentaje de tiempo de ejecución de cada una.

\begin{table}[!htp]
\begin{center}
\begin{tabular}{|r|r|r|r|r|r|r|}
\hline
	\%		&	cumulative  &	self	&			&	self	&	total \\
\hline          
	time	&	seconds		&	seconds	&	calls	&	s/call	&	s/call	&	name \\    
\hline
 	91.87	&	1.53		&	1.53	&	448399	&	0.00	&	 0.00	&	particionar \\
\hline
	2.40	&	1.57		&	0.04	&	448801	&	0.00	&	0.00	&	cargarBuffer \\
\hline
	1.80	&	1.60		&	0.03	&	3565398	&	0.00	&	0.00	&	swap \\
\hline
	1.80	&	1.63		&	0.03	&	1		&	0.03	&	0.07	&	parseLineas \\
\hline
	1.80	&	1.66		&	0.03	&	1		&	0.03	&	1.67	&	sort \\
\hline
	0.60	&	1.67		&	0.01	&	1		&	0.01	&	1.57	&	quickSort\_r \\
\hline
	0.00	&	1.67		&	0.00	&	1		&	0.00	&	0.00	&	check\_param \\
\hline
	0.00	&	1.67		&	0.00	&	1		&	0.00	&	1.57	&	quick\_sort \\
\hline
\end{tabular}
\caption{Ejemplo de tabla.} \label{tab002}
\end{center}
\end{table}
 
Se aprecia en la tabla que la función particionar ocupa el 91,87\% del tiempo de ejecución de programa, convirtiéndola en la candidata para mejorar.
Si ésta fuera arbitrariamente mejorable, el speedup máximo es 12,3.
% La fórmula es la de
% speedup total = 1/(1-f + f/SM)
% f = 0,9187; SM tiende a infinito por ser arbitrariamente mejorable
% speedup máximo = 1/0,0813 = 12,3
\newpage

\section{Comandos de ejecución y corridas de prueba}

Comandos de Compilación:

\begin{itemize}
 \item make all: genera el programa, modo "release"
 \item make test: genera un programa de prueba
 \item make debug: genera el programa con flags para debugging
 \item make asm: genera los archivos Assemblies, sin generar el programa
 \item make gprof: genera el programa con flags para \textbf{gprof}
 \item make clean: remueve los archivos generados
\end{itemize}

Comandos de Ejecución:

\begin{itemize}
 \item tp0 [OPTIONS] [file...]
 \item $<$stdout$>$ $|$ tp0 [OPTIONS]
 \item -h, --help
 \item -V, --version
 \item -q, --quicksort
 \item -s, --stoogesort
\end{itemize}



\section{Conclusiones}

El presente trabajo, a modo de introducción, nos inicializó en las herramientas que usaremos en los trabajos siguientes. % sinonimia cero

Pudimos manejar la máquina virtual MIPS e interpretar un archivo de profiling, como si estuviésemos optimizando un programa real.

% Citas bibliográficas.
\begin{thebibliography}{99}

\bibitem{HEN00} J. L. Hennessy and D. A. Patterson, ``Computer Architecture. A Quantitative
Approach,'' 3ra Edición, Morgan Kaufmann Publishers, 2000.

\end{thebibliography}

\end{document}
