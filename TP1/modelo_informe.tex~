%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definición del tipo de documento.                                           %
% Posibles tipos de papel: a4paper, letterpaper, legalpapper                  %
% Posibles tamaños de letra: 10pt, 11pt, 12pt                                 %
% Posibles clases de documentos: article, report, book, slides                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[a4paper,10pt]{article}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Los paquetes permiten ampliar las capacidades de LaTeX.                     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Paquete para inclusión de gráficos.
\usepackage{graphicx}

% Paquete para definir la codificación del conjunto de caracteres usado
% (latin1 es ISO 8859-1).
\usepackage[latin1]{inputenc}

% Paquete para definir el idioma usado.
\usepackage[spanish]{babel}

\usepackage{multirow} 

% Paquete para fórmulas matemáticas
\usepackage{amsmath}
\newcommand{\BigO}[1]{\ensuremath{\operatorname{1}\bigl(#1\bigr)}}

%\usepackage{multicolumn} 

% Título principal del documento.
\title{		\textbf{Trabajo práctico 0: Infraestructura básica}}

% Información sobre los autores.
\author{	Alejandro García Marra, \textit{Padrón Nro. 91.516}                     \\
            \texttt{ alemarra@gmail.com }                                              \\
            Sebastián Javier Bogado, \textit{Padrón Nro. 91.707}                     \\
            \texttt{ sebastian.j.bogado@gmail.com }                                              \\
            \normalsize{Grupo Nro. 0 - 2do. Cuatrimestre de 2012}                       \\
            \normalsize{66.20 Organización de Computadoras}                             \\
            \normalsize{Facultad de Ingeniería, Universidad de Buenos Aires}            \\
       }
\date{}



\begin{document}

% Inserta el título.
\maketitle

% Quita el número en la primer página.
\thispagestyle{empty}

% Resumen
\begin{abstract}

El presente trabajo busca crear un programa que permita el ordenamiento de archivos a través del algoritmo Stooge sort, aproximando a un comportamiento minimalista del comando \textit{sort}. Se comparar\'a la versi\'on implementada en C contra la misma funci\'on escrita en assembly\\

\end{abstract}

\newpage
\section{Introducción}

Muchas veces tanto para programas recién terminados, como para aquellos que llevan un tiempo en funcionamiento, se desconoce realmente qué partes del programa insumen la mayor cantidad de recursos, sean estos de tiempo, carga de cpu, etc.
Poseer esta información se torna en algo crítico cuando se busca realizar una mejora de performance en dicho programa. Sería poco útil intentar optimizar a ciegas, por no decir inútil.\\
Haremos uso entonces de dos herramientas distintas, el profiling del código (por medio de \textit{gprof}) y la medición de los tiempos de ejecución (por medio de \textit{time}). 

\subsection{Stooge sort}
El Stooge sort es un algoritmo de ordenamiento recursivo muy ineficiente, de complejidad \BigO {n^{\log{3}/\log{1,5}}}.\\
Realiza el intercambio entre el primer y último de los elementos si es el primero es mayor (en ordenamiento ascendente). Luego, si el conjunto está compuesto por al menos tres valores, entonces aplica Stooge sort a los primeros dos tercios, luego a los dos últimos tercios, y finalmente repite con los primeros dos tercios. 


\section{Flujo del programa}

El programa comienza verificando el primer parámetro recibido. Si no existe o no es reconocido, sucede el comportamiento por defecto, que es el mensaje de ayuda, información sobre el uso. Con esto, termina la ejecución. 
Otro camino rápido en la aplicación es al solicitar la versión, con el parámetro \texttt{-V} o \texttt{--version}.\\

En una ejecución normal, el primer parámetro comienza la lista de archivos a procesar.


Una vez en la función \texttt{sort}, se arma el conjunto de líneas a ser reordeanadas recolectándolas de a un archivo por vez. Si no hubiera archivos, se trabaja con la entrada estándar con la misma función (\texttt{parseLineas}, que se detallará en breve).\\

Armado el conjunto, se llama a la función stoogesort pasándole como parámetros el vector de líneas y la cantidad de elementos. Luego se imprimen por salda estándar y se libera la memoria reservada.\\


La lectura de cada archivo sucede en la función \\
\texttt{unsigned parseLineas(char** *pLinea, unsigned lineas, FILE* stream)}:

\begin{itemize}
 \item \texttt{pLinea}: puntero a un arreglo de punteros a char
 \item \texttt{lineas}: cantidad de elementos del arreglo
 \item \texttt{stream}: archivo desde donde se llevarán a cabo las lecturas
 \item \texttt{return}: cantidad de elementos en el arreglo después del proceso
\end{itemize}

Esta función carga en un buffer el archivo y lo recorre en busca del caracter de fin de línea. Por cada uno encontrado, se aloca espacio para un string, y se agrega al vector. Si el archivo no termina naturalmente como una línea, se agrega al final el \texttt{EOL}. Retorna con la cantidad de líneas cargadas (las acumuladas y las nuevas del archivo actual).


\section{Mediciones}

\subsection{Valores Obtenidos}

En la tabla~\ref{tab001} se presentan las mediciones realizadas con \textbf{time} sobre ambos algoritmos de ordenamiento y con archivos de distintos tamaños.\\

Además de los archivos indicados en el enunciado, fueron agregadas mediciones sobre archivos con tamaños arbitrarios, mayores, con el fin de mostrar de mejor manera las diferencias entre algoritmos.

\begin{table}[!htp]
\begin{center}
\begin{tabular}{cc|c|c|c|c|c|c|} 
\cline{3-8}
& & \multicolumn{3}{ c|}{Stoogesort.c$^{*}$} & \multicolumn{3}{c|}{Stoogesort.S}\\ \cline{3-8}
&   & Ordenado & Invertido & Aleatorio & Ordenado & Invertido & Aleatorio \\ \cline{1-8}

\multicolumn{1}{|c}{\multirow{3}{*}{1kb}} &
\multicolumn{1}{|c|}{real$^{*}$} & 0.03 & 0.01 &0.03 		& 0.03 	& 0.01 		& 0.01 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{user$^{*}$} & 0.04 & 0.02 &0.05		 & 0.05	& 0.00 		& 0.00 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{sys$^{*}$} & 0.00 & 0.00 &0.00 		&  0.00 	& 0.03 		& 0.02 \\ \cline{1-8}

\multicolumn{1}{|c}{\multirow{3}{*}{8kb}} &
\multicolumn{1}{|c|}{real} & 0.38 & 0.38 &0.40 		& 0.38 	& 0.36 		& 0.38 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{user} & 0.38 & 0.39 &0.40		 & 0.36 	& 0.38 		& 0.38 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{sys} & 0.00 & 0.00 &0.01 		& 0.01 	& 0.00 		& 0.01 \\ \cline{1-8}

\multicolumn{1}{|c}{\multirow{3}{*}{16kb}} &
\multicolumn{1}{|c|}{real} & 0.35 & 0.34 &0.34 		& 0.33 	& 0.34 		& 0.33 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{user} & 0.33 & 0.36 &0.35 		& 0.32	 & 0.34 	& 0.34 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{sys} & 0.01 & 0.00 &0.00 		& 0.02 	& 0.00 		& 0.00 \\ \cline{1-8}

\multicolumn{1}{|c}{\multirow{3}{*}{32kb}} &
\multicolumn{1}{|c|}{real} & 10.26 & 10.26 &10.21 		& 9.89 	& 9.86 		& 9.88 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{user} & 10.26 & 10.23 &10.22			 & 9.89 	& 9.88 		& 9.86 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{sys} & 0.00 & 0.05 &0.00		 & 0.01 	& 0.00 		& 0.01 \\ \cline{1-8}

\multicolumn{1}{|c}{\multirow{3}{*}{64kb}} &
\multicolumn{1}{|c|}{real} & 96.89 & 97.09 &96.66		 & 93.24 	& 93.34		& 93.29 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{user} & 96.88 & 97.00 &96.63		& 93.24 	& 93.31		& 93.29 \\ \cline{2-8}
\multicolumn{1}{|c}{}                        &
\multicolumn{1}{|c|}{sys} & 0.01 & 0.03 &0.02		& 0.00 	& 0.00 		& 0.00 \\ \cline{1-8}
\end{tabular}
\caption{Resultados comando Time } \label{tab001}
\end{center}
\end{table}

$^{*}$ Referencias: 

Ambos fuentes utilizan la versi\'on hecha en assembly del comparador de lineas, \textit{strcmp.S}
\begin{itemize}
 \item real: \%e, tiempo total real usado por el proceso.
 \item user: \%U, total de segundos-CPU usados por el proceso directamente.
 \item sys : \%S, total de segundos-CPU utilizados por el systema en nombre del proceso.
\end{itemize}

\newpage

\subsection{Análisis de los datos}

Como era de esperarse, se aprecia una leve mejora en los tiempos de ejecuci\'on para la rutina implementada en assembly. La diferencia no es notoria ni importante, as\'i como tampoco se logran los tiempos m\'inimos necesarios
para que estos algoritmos puedan usarse en forma cotidiana y confiable (la naturaleza poco eficiente del algoritmo es un defecto insalvable).


\subsection{Diagramas de Stack}

Para las funciones:
\begin{itemize}
 \item {void stoogesort(void* array, unsigned int i, unsigned int j);}{
 
  Realiza llamados recursivos, as\'i como tambi\'en llamados a strcmp.}
  
 \item {int strcmp(char** array1, char** array2);}{
 
 Funci\'on hoja}
\end{itemize}


\begin{table}[!htp]
\begin{center}
\begin{tabular}{|c|c|} 
\hline
 Funci\'on & Stack \\ \hline

 \multirow{14}{*}{Stoogesort}
        & 	\$ra    \\ \cline{2-2}
	&	\$fp	\\ \cline{2-2}
	&	\$gp	\\ \cline{2-2}
	&	\$s6	\\ \cline{2-2}
	&	\$s5	\\ \cline{2-2}
	&	\$s4	\\ \cline{2-2}
	&	\$s3	\\ \cline{2-2}
	&	\$s2	\\ \cline{2-2}
	&	\$s1	\\ \cline{2-2}
	&	\$s0	\\ \cline{2-2}
 	&	\small{padding}	\\ \cline{2-2}
	&	Argumento 2	\\ \cline{2-2}
	&	Argumento 1	\\ \cline{2-2}
	&	Argumento 0	\\ \cline{1-2}
\multirow{2}{*}{strcmp}
        &  	\$fp 	\\ \cline{2-2}
	&	\$gp	\\ \cline{1-2}
\end{tabular}
\caption{Resultados comando Time } \label{tab001}
\end{center}
\end{table}


\newpage

\section{Comandos de ejecución y corridas de prueba}

A menos que se indique lo contrario, siempre se compilan los fuentes *.S directamente.

Comandos de Compilación:

\begin{itemize}
 \item make all: genera el programa, modo "release"
 \item make debug: genera el programa con flags para debugging
 \item make cdebug: idem, pero con el fuente stoogesort.c (Ejecutable tp1\_c)
 \item make asm: genera los archivos Assemblies, sin generar el programa
 \item make gprof: genera el programa con flags para \textbf{gprof}
 \item make clean: remueve los archivos generados

\end{itemize}

\bigskip

Comandos de Ejecución:

\begin{itemize}
 \item tp1 [OPTIONS] [file...]
 \item $<$stdout$>$ $|$ tp1 [OPTIONS]
 \item -h, --help
 \item -V, --version
\end{itemize}


\bigskip

Archivos de prueba presentes en el cd:

  \begin{itemize}
   \item 1kb ordenado, invertido, random
   \item 8kb ordenado, invertido, random
   \item 16kb ordenado, invertido, random
   \item 32kb ordenado, invertido, random
   \item 64kb ordenado, invertido, random
  \end{itemize}
  
\bigskip

Archivos de fuente presentes en el cd (ver Anexo I):

  \begin{itemize}
   \item Makefile
   \item main.c
   \item parseManager.c
   \item parseManager.h
   \item sort.c
   \item sort.h
   \item stoogesort.S
   \item stoogesort.c
   \item stoogesort.h
   \item strcmp.S
  \end{itemize}




\section{Conclusiones}

Con la realización de este tp, pudimos interiorizarnos en parte del trabajo realizado por el compilador, al reemplazar el código assembly (.s) generado por este a partir de un fuente (.c) por código propio.



Uno de los objetivos era obtener una mejor performance de la rutina, ya que el código generado por el compilador en muchos casos no es el más eficiente posible, agregando instrucciones innecesarias en la traducción. 
Este objetivo se vió completado, como muestran las mediciones, pero sin lograr un impacto importante sobre el tiempo de ejecución real de la rutina. Esto se debe a varias razones, incluidas la impericia de los programadores,
pero principalmente se ve afectado por la naturaleza poco eficiente del algoritmo. No importa cuanto se optimice, el stoogesort nunca será un algoritmo veloz.



%citas bibliográficas
\begin{thebibliography}{99}

\bibitem{HEN00} J. L. Hennessy and D. A. Patterson, ``Computer Architecture. A Quantitative
Approach,'' 3ra Edición, Morgan Kaufmann Publishers, 2000.

\bibitem{?MIPS ABI: Function Calling Convention,? Organizaci ?n de computadoras - 66.20
}
\end{thebibliography}

\end{document}
